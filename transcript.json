[{"start_time": 0, "text": " So, hello everyone. Welcome to the PC Seminar. Today we have this Professor Amir Mohad from"}, {"start_time": 0, "text": " American University of Beirut and he'll be talking on the GERT and Parametri's complex"}, {"start_time": 10, "text": " city of token sliding and token jumping. Thank you for joining us, Professor. Over to you now."}, {"start_time": 10, "text": " Thank you, President. Thank you for having me. It's a real pleasure to be here."}, {"start_time": 20, "text": " So, all right, let's jump right into it. So, since I did not really know the audience too well,"}, {"start_time": 30, "text": " I made the assumption that many of you maybe have not seen this area of combinatorial"}, {"start_time": 30, "text": " reconfiguration problems. So, I decided what I'm going to do is I'm going to give a gentle introduction"}, {"start_time": 40, "text": " to the area just to show you how many exciting problems and open problems are there."}, {"start_time": 50, "text": " And then I will talk more about token jumping and token sliding, specifically what we know about them,"}, {"start_time": 50, "text": " what we knew about them before we started working on this project, what we managed to discover"}, {"start_time": 60, "text": " and the tons of questions that remain to be answered. Right, and it's a really,"}, {"start_time": 70, "text": " I mean, the questions are so nice to state, so easy to state, and they are accessible really to"}, {"start_time": 70, "text": " researchers at any level, which is one of the reasons why I enjoy working on these problems. So,"}, {"start_time": 80, "text": " so hopefully you'll get to enjoy them too. So, before I start, I should point out that this is"}, {"start_time": 90, "text": " joint work that started back in the combinatorial reconfiguration workshop almost two years ago."}, {"start_time": 100, "text": " And it's joint work with Valentine Bart\u00e9, Nicolabuske, Le Mandalard, and Karl Lomer,"}, {"start_time": 100, "text": " who is my master's student. All right, so the outline of the talk, it's going to be in four sections."}, {"start_time": 110, "text": " I will give a gentle introduction to combinatorial reconfiguration, because I know many of you might not"}, {"start_time": 120, "text": " have seen such problems. Then I will talk about token jumping and token sliding, what we know about"}, {"start_time": 130, "text": " them in terms of classical complexity or one-dimensional complexity. Then I'll talk about the"}, {"start_time": 130, "text": " parameter as complexity of these two problems and what we know as of today, as we speak,"}, {"start_time": 140, "text": " and what are the problems that remain to be solved. And then the last part of the lecture is where"}, {"start_time": 150, "text": " I will put some of the technical stuff to show you to give you an idea about how we prove things"}, {"start_time": 150, "text": " when we deal with such problems and where are the difficulties and what kind of techniques"}, {"start_time": 160, "text": " have been developed. So I tried to keep the technical part as light as I could so that really we,"}, {"start_time": 160, "text": " I mean, I can focus on the big picture and the questions to be asked and answered. So if you have"}, {"start_time": 170, "text": " any questions along the way, please feel free to interrupt me either in the chat or by unmuting"}, {"start_time": 180, "text": " yourselves. So don't worry about leaving the questions till the end. You can interrupt me whenever"}, {"start_time": 180, "text": " you feel, whenever I say something that doesn't make sense. Hopefully that won't happen too often."}, {"start_time": 190, "text": " All right, so what is combinatorial configuration? So the best way I think to introduce is with a"}, {"start_time": 200, "text": " familiar example, which is one player games and the most common one that we use is the 15 puzzle"}, {"start_time": 210, "text": " game. So for those of you who don't know the 15 puzzle games, so you're given like a 4x4 grid"}, {"start_time": 210, "text": " and you have one empty square and basically you have all the remaining 15 squares are numbered"}, {"start_time": 220, "text": " from 1 to 15 and they come in some ordering and your job is to basically move the squares around"}, {"start_time": 230, "text": " so that all the numbers become ordered. So it's a by-ro so they have to be ordered this way. So if you"}, {"start_time": 230, "text": " notice in this figure, the only problem is that 14 and 15 are reversed but the only moves that"}, {"start_time": 240, "text": " you're allowed to do is to basically move a number into the empty square. And basically you have"}, {"start_time": 250, "text": " to do a sequence of moves so that you get all of the numbers in order. And for those of you who know"}, {"start_time": 250, "text": " this game, this example that I have on the slide is actually unsolved. There is no way you can"}, {"start_time": 260, "text": " flip the order in 15 of 14 and 15 in this puzzle. And I have a link here if you want to actually"}, {"start_time": 270, "text": " play the puzzle online which is pretty fun. So why do I do I start my talk by talking about"}, {"start_time": 280, "text": " 15 puzzle? It's because it's really I mean the way you solve the 15 puzzle tells you a lot about"}, {"start_time": 280, "text": " the area of combinatorial reconfiguration. So the standard way we would think about the 15 puzzle"}, {"start_time": 290, "text": " is by looking at the state space or what we call the reconfiguration graph of the 15 puzzle."}, {"start_time": 300, "text": " So what does that graph consist of? Well, we have one vertex or one node in this graph"}, {"start_time": 300, "text": " for each possible configuration of the puzzle. So basically each possible configuration so it"}, {"start_time": 310, "text": " would be a possible permutation of the 15 numbers in addition to where you're going to put the empty"}, {"start_time": 310, "text": " square. Each one of those will be a vertex in the graph. And now we connect two vertices in that"}, {"start_time": 320, "text": " graph whenever one can be reached from the other by a single move. And what do we mean here by a"}, {"start_time": 330, "text": " single mover? It's basically just moving a number into the empty square. So if you look at the top"}, {"start_time": 340, "text": " node here in this graph, there are four possibilities that you can do in one move which we call"}, {"start_time": 340, "text": " a reconfiguration step which is you can move nine into the empty square. You can move three into"}, {"start_time": 350, "text": " the empty square, 12 or 15. And that gives us basically four neighbors of that vertex in the graph."}, {"start_time": 360, "text": " Okay, and we call this whole graph the reconfiguration graph or the state space if you're more"}, {"start_time": 360, "text": " comfortable thinking about states, the states of the game. So now given this graph, the reconfiguration"}, {"start_time": 370, "text": " graph, there are tons of very interesting questions that you can ask about it. There are structural"}, {"start_time": 380, "text": " questions and there are algorithms to make questions. And these are typically the types of questions"}, {"start_time": 380, "text": " that we're interested in in this area of combinatorial reconfiguration. So a couple of examples of"}, {"start_time": 390, "text": " structural questions would be, well, the simplest one would be how big is this reconfiguration graph,"}, {"start_time": 400, "text": " right? How many vertices or how many edges? And that's usually not a very hard question to answer"}, {"start_time": 400, "text": " in terms of upper and lower ones. More interestingly, you could ask, is this reconfiguration graph"}, {"start_time": 410, "text": " connected, right? Or is, can I reach any state starting from any other state by a sequence of legal moves?"}, {"start_time": 420, "text": " And as I told you before, for the 15 puzzle, the reconfiguration graph is definitely not connected"}, {"start_time": 420, "text": " because there was no way to reverse 14 and 15 in the previous example that I showed you and you can"}, {"start_time": 430, "text": " easily prove that, by the way. So when it's not connected, another question would be how many components"}, {"start_time": 440, "text": " does I have? Is there some sort of a nice structure to the components of this graph? And then"}, {"start_time": 450, "text": " another question would be what is the diameter of the circumfiguration graph or of each one of its"}, {"start_time": 450, "text": " components? And that's usually a very important question to ask when you're dealing with one player"}, {"start_time": 460, "text": " games because this could tell you like what would be the worst possible shortest path to reach a"}, {"start_time": 460, "text": " target configuration or to solve your game, to win your game, for example. And in the literature,"}, {"start_time": 470, "text": " this is sometimes known as God's number, which would be the diameter of the reconfiguration graph."}, {"start_time": 480, "text": " And these are all very interesting, very interesting structural questions to ask about this reconfiguration"}, {"start_time": 480, "text": " graph. Now on the algorithmic side or the computational side, there's the obvious question of if I'm given"}, {"start_time": 490, "text": " a starting state and some ending state or target state, like in the case of the puzzle game,"}, {"start_time": 500, "text": " that I am given some starting state and we know what the goal state is. So here one decision"}, {"start_time": 500, "text": " problem would be to answer the question whether it's possible to get to the target state starting"}, {"start_time": 510, "text": " from some initial state that is also given to me. So you can decide to solve this problem either as"}, {"start_time": 510, "text": " a decision problem or as a search problem, which would give you the actual sequence of steps that"}, {"start_time": 520, "text": " will take you from a state to the target state. Other interesting computational problems,"}, {"start_time": 530, "text": " is it always possible to go from one configuration to any other? And this is basically also related to"}, {"start_time": 530, "text": " the structural question about connected components. And the last question that I will mention,"}, {"start_time": 540, "text": " which is also interesting, is how fast can you go from one configuration to another? Meaning,"}, {"start_time": 550, "text": " can you do it in at most case steps? There is a question I should wait or no. All right."}, {"start_time": 560, "text": " So think about all of these questions that we paused using the simple 15 puzzle game. And now we're"}, {"start_time": 570, "text": " going to look at a lot of other possible problems where the same any configuration graph can be extracted."}, {"start_time": 580, "text": " And we can ask the same set of questions. So all of you here are familiar with the case sad problem."}, {"start_time": 590, "text": " So you're given a Boolean formula and you want to know if you can satisfy this formula by assigning"}, {"start_time": 590, "text": " values to the variables. And we know that this is NP complete for K greater than or equal to 3."}, {"start_time": 600, "text": " So now how can you transform this into a reconfiguration problem? Well, it's very simple. So now you're"}, {"start_time": 600, "text": " given a formula and you're given two satisfying assignments. So you can think of those satisfying"}, {"start_time": 610, "text": " assignments as bit vectors. And so now the question that you can ask is can I go from the first"}, {"start_time": 620, "text": " satisfying assignment as to the next one? By basically flipping one bit at a time"}, {"start_time": 630, "text": " under the condition that I remain a satisfying assignment at all times. And notice that without"}, {"start_time": 630, "text": " this condition, the problem is trivial. So you can basically just flip the bits however you like and"}, {"start_time": 640, "text": " reach S from T or T from S. But once you have this constraint of you should remain a satisfying"}, {"start_time": 650, "text": " assignment, the problem becomes way more interesting. And you can think of this problem again as walking"}, {"start_time": 650, "text": " in the solution space of the given formula of all the satisfying assignment of the formula."}, {"start_time": 660, "text": " All right. So that's the sat reconfiguration problem. Let's look at another example."}, {"start_time": 670, "text": " Graph coloring. We all know it. We all love it. You're given a graph and some integer K and you are"}, {"start_time": 680, "text": " asked whether you can properly cave color the graph G. And we know again that this is NP complete"}, {"start_time": 680, "text": " for K greater than or equal to 3. How do you transform that into a reconfiguration problem? Well,"}, {"start_time": 690, "text": " now you're given a graph. You're given two colorings of the graph, alpha and beta. And the question"}, {"start_time": 700, "text": " is can you recolor alpha to get the to beta? But you need to recolor one vertex at a time and you"}, {"start_time": 700, "text": " need to remain a proper K coloring throughout. Same idea again leads us to this notion of the"}, {"start_time": 710, "text": " reconfiguration space where we are looking at the K colorings of the graph and how they are connected"}, {"start_time": 720, "text": " under this adjacent simulation that we define, which is a single vertex recoloring."}, {"start_time": 730, "text": " The final example that I will mention, which will be basically what we will focus on in the rest of"}, {"start_time": 730, "text": " the talk is token placement. I call it, but as you will all guess, this is the famous independent set"}, {"start_time": 740, "text": " problem. But we will look at it as a token placement problem because it will be more useful for the"}, {"start_time": 740, "text": " rest of the talk. So you're given a graph G and an integer K. And the question is can you place K"}, {"start_time": 750, "text": " tokens on your graph K black tokens so that no two of these tokens share an edge. And of course,"}, {"start_time": 760, "text": " we all know that this is an NP complete problem. So how can you transform this problem into a reconfiguration"}, {"start_time": 760, "text": " problem? Again, now I'm given a graph, two independent sets of the graph, each of size K."}, {"start_time": 770, "text": " And the question is can I go from one independent set to the other under what rule? So here,"}, {"start_time": 780, "text": " defining the rule for independent set, how can I go between consecutive independent sets becomes"}, {"start_time": 780, "text": " a little bit less obvious. And there are two main strategies that people have attempted."}, {"start_time": 790, "text": " So the first rule is what we call token jumping. So you are basically allowed to take any token"}, {"start_time": 800, "text": " on your graph and jump it to any other vertex on the graph, assuming that it doesn't have a token"}, {"start_time": 800, "text": " and that you maintain an independent set at all times. So for example, in this example that I have here,"}, {"start_time": 810, "text": " it would be perfectly okay to take this token here and jump it to this vertex here."}, {"start_time": 820, "text": " Or I could also take this token here and jump it to this vertex here."}, {"start_time": 820, "text": " So that, no, actually that would violate the independence. So you can jump to any other vertex as long"}, {"start_time": 830, "text": " as you maintain independence. And we call that the token jumping rule. The other rule is basically"}, {"start_time": 840, "text": " token sliding. So in this case, we only allow a token to slide along edges of the graph."}, {"start_time": 850, "text": " So a token can only move to adjacent vertex, assuming of course this does not violate independence."}, {"start_time": 860, "text": " So now we have two different reconfiguration graphs we can think about. We can think about the"}, {"start_time": 860, "text": " reconfiguration graph under the token jumping adjacency. And we can think about the reconfiguration"}, {"start_time": 870, "text": " graph under the token sliding adjacency. And we're going to talk about these two different problems"}, {"start_time": 870, "text": " because they do actually behave quite differently. And they produce quite interesting results."}, {"start_time": 880, "text": " Like the difference between the two, we don't fully understand yet, but we kind of know that token"}, {"start_time": 880, "text": " sliding can be harder than token jumping. But there's still a lot of questions to be answered."}, {"start_time": 890, "text": " All right. So some of you might be asking why do we care about studying such problems?"}, {"start_time": 900, "text": " There's a lot of motivations out there. I mean, as sometimes I would say you don't need motivation,"}, {"start_time": 910, "text": " they're interesting. There's a lot of open questions that we need to answer. But you can also"}, {"start_time": 910, "text": " think about reconfiguration problems as another way of modeling real world algorithmic problems."}, {"start_time": 920, "text": " Because you usually never start from scratch. When you're trying to solve real world problems,"}, {"start_time": 920, "text": " you usually start from something and you're trying to prove it or make it better or change it"}, {"start_time": 930, "text": " to something more appropriate. Another very good application of studying these problems is that"}, {"start_time": 940, "text": " they give you a better understanding of solution spaces, which can be very important for other areas"}, {"start_time": 940, "text": " as well. And they have been used in statistical physics, quantum computing, and complexity theory,"}, {"start_time": 950, "text": " combinatorics, and robotics, and hopefully many more applications to come. But what I would tell you"}, {"start_time": 960, "text": " is that there are so many very interesting problems that are so easy to start thinking about"}, {"start_time": 960, "text": " without having too much background, which is why I think this is a very nice area to start working"}, {"start_time": 970, "text": " on at any level in your research career. All right. So I'll take a break here and take questions if"}, {"start_time": 980, "text": " there are any. And then we will dive into the token jumping and token sliding problems, what we know"}, {"start_time": 980, "text": " about them in terms of classical complexity. And what was basically the starting point for the project"}, {"start_time": 990, "text": " that led us to this paper. Any questions at this point? I'm, I'll apologize for the small context,"}, {"start_time": 1000, "text": " which I am interrupting here. So this is just to announce for the PC 301 workshop that will be"}, {"start_time": 1010, "text": " happening in December end. And this will be slightly different from the previous two workshops."}, {"start_time": 1020, "text": " First major difference, this will be online. Second is some advanced topics will be discussed. So"}, {"start_time": 1020, "text": " anyone who intends to explore somewhat more complex topics in parameterized algorithms is invited"}, {"start_time": 1030, "text": " to have a check. They can look at the website that has been shared on the chat. And if you wish,"}, {"start_time": 1040, "text": " you can register simply by filling a form that is linked at the bottom of the webpage. So just"}, {"start_time": 1040, "text": " to inform you all about it. And sorry for the interruption for this now. All right."}, {"start_time": 1050, "text": " All right. So let's start talking about token jumping, token sliding and a little bit about"}, {"start_time": 1060, "text": " classical complexity. I know everybody here knows about P and NP. So I'm not going to talk about this."}, {"start_time": 1070, "text": " Some of you might not be familiar with the piece space class. So just a quick note that's as much"}, {"start_time": 1070, "text": " as you will need to know for this talk is that piece space is the set of all decision problems"}, {"start_time": 1080, "text": " that can be solved using a polynomial amount of space. And the reason why I mentioned this class is"}, {"start_time": 1080, "text": " because many many many many reconfiguration problem actually are piece space complete."}, {"start_time": 1090, "text": " Okay. And so so what we know the standard inclusion is we know that P is contained in NP,"}, {"start_time": 1100, "text": " which is contained in piece space. But a very useful thing about piece space is that savage"}, {"start_time": 1100, "text": " prove that it's equal to NP space. So polynomial space and non deterministic polynomial space are"}, {"start_time": 1110, "text": " the same class. Basically, and that's extremely useful when you start to think about reconfiguration"}, {"start_time": 1120, "text": " problems because if you think about reconfiguration problem where you're given some state and you"}, {"start_time": 1120, "text": " want to reach the other one. So basically you can solve that easily in non deterministic polynomial"}, {"start_time": 1130, "text": " space, which basically implies that they are NP space. But actually you can show a lot more than that."}, {"start_time": 1140, "text": " You can show that many really many reconfiguration problems are actually piece space complete,"}, {"start_time": 1140, "text": " which is not surprising. Right. The fact that many of these reconfiguration problems are piece"}, {"start_time": 1150, "text": " space complete is not very surprising. Right. And then them not being in NP is because they don't"}, {"start_time": 1160, "text": " always have polynomial size certificates, which also makes sense because sometimes the number"}, {"start_time": 1160, "text": " of steps that you need to take to go from one configuration to the other might very well be"}, {"start_time": 1170, "text": " exponential in the graph. But there are also some extremely surprising results. And these are some"}, {"start_time": 1170, "text": " of the results some of my favorite results in the area. So for example, you all know that"}, {"start_time": 1180, "text": " coloring is NP complete even for k equals 3. However, it turns out that if you try to solve the"}, {"start_time": 1190, "text": " recoloring problem for k equals 3, it's actually polynomial time solvable. So if I give you two"}, {"start_time": 1200, "text": " three colorings of a graph and I ask you, is there a path between them that recolors one vertex at"}, {"start_time": 1200, "text": " a time and never is and is always a valid three coloring, then this problem can be solved in polynomial"}, {"start_time": 1210, "text": " time. And the recoloring problem only becomes piece space complete for k equal 4 and more."}, {"start_time": 1220, "text": " Right. So so that's the first surprising result. Another very surprising result is that"}, {"start_time": 1220, "text": " as as your old FBT experts here, I know that you're all familiar with the fact that usually when"}, {"start_time": 1230, "text": " we study problems on graphs of bounded bucket width, path width, tree width, they tend to become easier."}, {"start_time": 1240, "text": " It turns out that that's not really the case for reconfiguration problems, at least for token"}, {"start_time": 1240, "text": " sliding and jumping, which is the two problems that are related to independent set. It turns out"}, {"start_time": 1250, "text": " that those two problems remain piece space complete, even if you have a graph of constant tree width"}, {"start_time": 1250, "text": " or path width or even bucket width. So a very very very simple graph structure"}, {"start_time": 1260, "text": " still the problem remains hard."}, {"start_time": 1270, "text": " All right. And finally, the last theorem that I also like a lot shows you basically that"}, {"start_time": 1270, "text": " sliding and jumping behave differently. And it was shown that if you restrict yourself to"}, {"start_time": 1280, "text": " bipartite graphs, where we know that max independent set can be solved in polynomial time,"}, {"start_time": 1290, "text": " if you restrict yourself to those graphs, it turns out that token jumping is NP complete,"}, {"start_time": 1290, "text": " whereas token sliding is piece space complete, which is a which is a strange"}, {"start_time": 1300, "text": " difference between the behavior of those two problems."}, {"start_time": 1310, "text": " All right. So in fact, we know a lot more about token sliding and token jumping. These"}, {"start_time": 1320, "text": " problems have been at the heart of the area of combinatorial reconfiguration. They have been"}, {"start_time": 1320, "text": " studied so much. And we know so much about them at least in terms of standard or classical complexity."}, {"start_time": 1330, "text": " So some of the important results for for our paper that we're going to focus on"}, {"start_time": 1340, "text": " is this result. So that's going to be the starting point of the results that we will discuss"}, {"start_time": 1350, "text": " next when we move to parametrize complexity. So the fact that token sliding and token jumping"}, {"start_time": 1350, "text": " are piece space complete and then NP complete respectively on bipartite graphs was the"}, {"start_time": 1360, "text": " starting point of our next paper. But there are some very interesting results here that are"}, {"start_time": 1360, "text": " also worth mentioning. So for example, for even whole figure halves, we know how to solve token"}, {"start_time": 1370, "text": " jumping in polynomial time. But the complexity of independent set even remains open on this class"}, {"start_time": 1370, "text": " of graphs. And the complexity of token sliding also remains open. So we don't know how to check if,"}, {"start_time": 1380, "text": " given two independent sets, I can slide one to the other. Can you answer that question in"}, {"start_time": 1390, "text": " polynomial time for even whole free graphs? For split graphs and chordal graphs, they also"}, {"start_time": 1390, "text": " behave extremely differently token sliding and token jumping. So they are token sliding is"}, {"start_time": 1400, "text": " piece space complete on split graphs and chordal graphs while token jumping is polynomial time."}, {"start_time": 1410, "text": " And that is some of the reasons why we feel that token sliding is harder usually than token jumping."}, {"start_time": 1410, "text": " But it's not always the case. All right. So that's it for classical complexity."}, {"start_time": 1430, "text": " So now let's move on to parametrize complexity. And let's basically think about how you can"}, {"start_time": 1430, "text": " parametrize those two problems, token jumping and token sliding. So the obvious parameter would be"}, {"start_time": 1440, "text": " the number of tokens. So one of the obvious parameters would be the number of tokens. So"}, {"start_time": 1450, "text": " and we're going to denote that by K. Another parameter would be the length of the sequence."}, {"start_time": 1450, "text": " Like how many steps does it take to go from one independent set to the other?"}, {"start_time": 1460, "text": " You can also obviously parametrize by tree width or tath width or any combination of the above."}, {"start_time": 1460, "text": " When we started working on this problem, our initial aim was to basically study the"}, {"start_time": 1470, "text": " parametrize complexity of token sliding and token jumping on bipartite graphs using the parameter K"}, {"start_time": 1480, "text": " number of tokens. Right. Because remember, we saw that token sliding is piece space complete"}, {"start_time": 1480, "text": " on bipartite graphs and token jumping is NP. So you were interested to see if basically this is"}, {"start_time": 1490, "text": " going to give us W1 hardness for token sliding and fptinus for token jumping."}, {"start_time": 1490, "text": " All right. At least that was the initial hope. That's why we started working on this project."}, {"start_time": 1500, "text": " We weren't able to answer the two questions. So we were able to answer one side of the question,"}, {"start_time": 1510, "text": " which is we were able to show that on bipartite graphs token sliding is in fact W1 hard."}, {"start_time": 1520, "text": " So token sliding parametrize by the number of tokens on bipartite graphs is W1 hard."}, {"start_time": 1520, "text": " We were not able to answer the question for token jumping. So that is still an open question."}, {"start_time": 1530, "text": " So having answered that question and failed on the next question, we started thinking about ways"}, {"start_time": 1540, "text": " to basically simplify a little bit some of these questions. So the next thing we asked ourselves,"}, {"start_time": 1540, "text": " so there are two directions where you can try and simplify. So the next thing we asked"}, {"start_time": 1550, "text": " ourselves was, okay, so from bipartite graphs, how can I go to other classes of graphs"}, {"start_time": 1560, "text": " and see where token jumping becomes hard or easy? And it turned out that if you basically"}, {"start_time": 1570, "text": " exclude only C4 from your graph, right? And so we, because in bipartite graphs, you're excluding"}, {"start_time": 1570, "text": " all odd cycles, right? So we started thinking about what kinds of cycles affect the behavior of those"}, {"start_time": 1580, "text": " problems. So the first question was, what about C4 free graphs? And it turned out that both problems"}, {"start_time": 1590, "text": " remain W1 hard on C4 free graphs. Now if you exclude C3 and C4, it turns out that token jumping"}, {"start_time": 1600, "text": " becomes FPT, has an order K squared kernel, but for token sliding, we were not able to determine the"}, {"start_time": 1610, "text": " complexity. Now if you go to the other side of that, so what if we enforce both bipartite"}, {"start_time": 1620, "text": " tightness as well as C4 freeness? So in that case, we were able to show that both problems became FPT."}, {"start_time": 1630, "text": " Okay, and basically the bipartite bounded degree graphs was just a stepping stone to get to the"}, {"start_time": 1630, "text": " bipartite C4 free graph result. So let me, let me repeat that maybe slightly more clearly. So after"}, {"start_time": 1640, "text": " basically answering the first question, which was bipartite graphs, we were able to show that token"}, {"start_time": 1650, "text": " sliding was W1 hard, but we were not able to determine the complexity of token jumping. So then we"}, {"start_time": 1650, "text": " went to C4 free graphs, and we were able to show that both problems are actually W1 hard. Then if we"}, {"start_time": 1660, "text": " added one more constraint, which was C3, C4 free graphs, we got FPT-less for token jumping, but it"}, {"start_time": 1670, "text": " remained open for token sliding. And on the other side of the spectrum, so if we keep bipartite"}, {"start_time": 1680, "text": " and enforce the C4 freeness, we get FPT for both problems. And as a side note, this blue result"}, {"start_time": 1690, "text": " is not part of our paper. This was known prior to our paper. So any questions about the results?"}, {"start_time": 1700, "text": " No questions. All right, cool. So lots of open problems. The first and obvious one is,"}, {"start_time": 1720, "text": " what is the pattern is token jumping FPT, parameterized by K on bipartite graphs. And that's really,"}, {"start_time": 1730, "text": " I mean, that was the initial question that we set out to answer and couldn't. So that remains open."}, {"start_time": 1740, "text": " And it's, so I will not be going over the hardness reduction for token sliding on bipartite graphs"}, {"start_time": 1750, "text": " because it's quite technical. I don't feel a talk is the right place to go over it. But"}, {"start_time": 1760, "text": " if you go over the reduction, you will see that it's the two problems really behave differently."}, {"start_time": 1760, "text": " And there's that doesn't seem to be a chance to basically make the same type of reduction work for"}, {"start_time": 1770, "text": " token jumping. So the second interesting open question is, how about token jumping parameterized"}, {"start_time": 1780, "text": " by K on triangle free graphs? That's basically even more general than question one."}, {"start_time": 1780, "text": " Right? So, and the reason why I mentioned this question separately is because almost every reduction"}, {"start_time": 1790, "text": " that I know of includes large clicks. So you need to use large clicks in your reductions. So how about"}, {"start_time": 1800, "text": " if we don't allow trying those and large clicks? So can we can we can we then say something about"}, {"start_time": 1800, "text": " the problem? So that's for token jumping. Now, when when you go to token sliding,"}, {"start_time": 1810, "text": " so the open problem is what happens for token sliding on graphs of girth at least five,"}, {"start_time": 1820, "text": " so if they are C3, C4 free, or you can even make that a bit weaker and ask for any girth of at least"}, {"start_time": 1820, "text": " P for some constant P. And for all of these questions, of course, polynomial kernels"}, {"start_time": 1830, "text": " would be interesting as well. Because in our case, we do get polynomial kernels for the FPT."}, {"start_time": 1840, "text": " And the polynomials are not great, but polynomial regardless."}, {"start_time": 1850, "text": " All right. So in the rest of the talk, I will try to cover some of the technical stuff."}, {"start_time": 1860, "text": " And as promised, I will try to keep it as light as possible so that I can give you some of"}, {"start_time": 1860, "text": " a lot of the intuition and techniques that are used in this paper and that are generally used"}, {"start_time": 1870, "text": " when dealing with reconfiguration problems. So the first result that we will go over is this"}, {"start_time": 1880, "text": " W hardness on C4 free graphs. Right? For both token sliding and token jumping. It's the"}, {"start_time": 1880, "text": " same reduction and you will get both results because we will be using maximum independent sets."}, {"start_time": 1890, "text": " So if you're trying to basically do token sliding from one maximum independent set to the other,"}, {"start_time": 1900, "text": " or token jumping, these two rules become equivalent. Jumping becomes equivalent to sliding."}, {"start_time": 1900, "text": " So when you're dealing with maximum independent sets, these two basically rules are the same."}, {"start_time": 1910, "text": " And that's what we're going to do. But what we're going to prove actually is a stronger"}, {"start_time": 1910, "text": " theorem. What we're going to prove is the following theorem. If you take any p greater than or equal"}, {"start_time": 1920, "text": " to four, then both problems are W hard on C4, C5 dot dot dot up to Cp free graphs,"}, {"start_time": 1930, "text": " which implies of course C4 free graphs. But you can basically exclude any cycles from C4 up to"}, {"start_time": 1940, "text": " Cp for constant p and the problems will remain W1 hard. So how do we prove this result? In fact,"}, {"start_time": 1950, "text": " we use a known reduction from a problem known as grid tiling, which is a W1 hard problem."}, {"start_time": 1960, "text": " And grid tiling is reduced to the independent set problem on C4 up to Cp free graphs."}, {"start_time": 1970, "text": " And that reduction was used to show that independent set remains W1 hard if you exclude C4 up to"}, {"start_time": 1980, "text": " Cp for any constant p. But what is interesting and useful in that reduction is the graph that is"}, {"start_time": 1990, "text": " obtained from the reduction. So the graph that is obtained from the reduction has three properties"}, {"start_time": 1990, "text": " that are going to be useful to us. The first property is that you can partition the graph"}, {"start_time": 2000, "text": " into basically 8k squared into p plus 1 clicks. So you have a bunch of clicks, each of size n,"}, {"start_time": 2010, "text": " and all of the edges basically are between the clicks. But that's it, that's the whole of the graph."}, {"start_time": 2020, "text": " It's a bunch of clicks and edges between them. Of course, the more important property as well here"}, {"start_time": 2020, "text": " is that this graph is going to be C4 up to Cp free. It will not have any of those cycles as an"}, {"start_time": 2030, "text": " induced subgraph. And it's an equivalent instance to the grid tiling. And that basically gives you"}, {"start_time": 2040, "text": " a W1 hardness of independent set on this class of graphs. So notice in this case that an"}, {"start_time": 2050, "text": " independent set of size 8k squared into p plus 1 will have to be a maximum independent set,"}, {"start_time": 2060, "text": " because that's how many clicks we get in the resulting graph. And that's basically the sizes"}, {"start_time": 2060, "text": " that we will be working with, more or less up to some modifications. But this will allow us to"}, {"start_time": 2070, "text": " basically conclude that both sliding and jumping are hard on this class of graphs."}, {"start_time": 2080, "text": " So how do we use this for showing hardness of token sliding and token jumping? And let's focus"}, {"start_time": 2080, "text": " on token sliding for now, because it's going to be the same anyway. So we have those clicks"}, {"start_time": 2090, "text": " and some edges that go between the clicks. So the first attempt would be as follows. We will add"}, {"start_time": 2100, "text": " a universal vertex to each one of the clicks and we will call this the starting set or the starting"}, {"start_time": 2100, "text": " independent set. And then we add another universal vertex to each one of the clicks and call this"}, {"start_time": 2110, "text": " the target independent set. And now basically we have our instance of token sliding. We want to"}, {"start_time": 2120, "text": " slide everybody in S down to T. So notice that this is useful because we don't introduce any of the"}, {"start_time": 2130, "text": " forbidden cycles. So we are still fine. And if we could guarantee that all of the tokens will be"}, {"start_time": 2130, "text": " on the on the clicks simultaneously, then this will imply an independent set in the original graph,"}, {"start_time": 2140, "text": " which concludes our proof. But unfortunately in this case, we definitely cannot conclude that,"}, {"start_time": 2150, "text": " because each red token can slide independently here and then here and then the next one can follow"}, {"start_time": 2160, "text": " etc etc etc. So you need some way of forbidden, or forbidding these tokens to behave freely."}, {"start_time": 2160, "text": " We want to make sure that they will all be inside the clicks simultaneously and we will be done."}, {"start_time": 2170, "text": " And notice that we're going to have 8k squared and 2p plus 1 tokens, right? 1 for each click"}, {"start_time": 2180, "text": " and 2 universal vertices for each click. So how do we fix this time of 1080 to issue? Well,"}, {"start_time": 2190, "text": " here's how we can do it. So instead of simply adding universal vertices, we're also going to add"}, {"start_time": 2190, "text": " an edge between every two universal vertices of a click. And then we're going to add something"}, {"start_time": 2200, "text": " that we call a switch. And in this case, it's a simple edge and the red token here needs to go to"}, {"start_time": 2210, "text": " the blue position. Right? So now we have one extra token inside our graph. But now notice what happens."}, {"start_time": 2210, "text": " If any red token wants to come to the blue position, then this red token needs to be moved to"}, {"start_time": 2220, "text": " this position before. And if you move that token up to the blue position, then you can no longer have"}, {"start_time": 2230, "text": " any of the red tokens on the universal vertices, which means that they will all have to be simultaneously"}, {"start_time": 2240, "text": " inside the clicks. And now we get the behavior that we want. So now we can guarantee that if there"}, {"start_time": 2250, "text": " is a sequence that takes the red tokens to the blue position, then somewhere along that sequence,"}, {"start_time": 2250, "text": " the tokens are all going to be within the clicks. Unfortunately, what happened here is we might"}, {"start_time": 2260, "text": " have introduced some of the forbidden cycles. We can no longer guarantee that this is c4 up to cp3."}, {"start_time": 2270, "text": " So what you can do in this case to solve this problem, and I'm not going to go into the details,"}, {"start_time": 2270, "text": " but the intuition should be pretty clear, is that you can subdivide those edges, make them long enough"}, {"start_time": 2280, "text": " so that you don't introduce any forbidden cycles and add appropriate tokens inside of them to get"}, {"start_time": 2290, "text": " the same behavior. Because notice that the number of such edges is bounded by a function of k,"}, {"start_time": 2300, "text": " a by a function of yes k and p. Right, so you can make these edges subdivide them as many times as"}, {"start_time": 2310, "text": " needed, add as many tokens as needed to maintain all the properties that we need and to maintain"}, {"start_time": 2310, "text": " that we're going from one maximum independent set to the other, which will give you W1 hardness"}, {"start_time": 2320, "text": " for both token sliding as well as token jumping."}, {"start_time": 2330, "text": " All right, questions?"}, {"start_time": 2340, "text": " No questions. All right, so let's keep going."}, {"start_time": 2350, "text": " So now I'm going to talk about some positive, a positive result."}, {"start_time": 2350, "text": " So the result that I'm going to talk about is this one here."}, {"start_time": 2360, "text": " Right, so I'm going to show you that on c3c4 free graphs, token jumping is actually"}, {"start_time": 2370, "text": " fpt and has a quadratic kernel. But again, what we will show is a stronger result."}, {"start_time": 2370, "text": " So what we will show is the following theorem. What we will show"}, {"start_time": 2380, "text": " is can be summarized as follows. So if you look at any graph"}, {"start_time": 2390, "text": " or at any instance of the token jumping problem. So remember, an instance of token jumping has"}, {"start_time": 2390, "text": " an input graph, the starting set, the target set and k as the number of tokens."}, {"start_time": 2400, "text": " So let me try and draw something here. So if you look at your graph, you can kind of decompose"}, {"start_time": 2410, "text": " it into something which is more or less as follows. So you have s, you have t, their intersection"}, {"start_time": 2420, "text": " need not be empty. And then you have the neighborhood of s union t."}, {"start_time": 2420, "text": " And then you have the rest of the graph. So we're going to call the rest of the graph, H."}, {"start_time": 2430, "text": " And we're going to call the closed neighborhood of s union t, or if you will, this"}, {"start_time": 2440, "text": " yellow part here, we call that j. Right, so we can think of our problem of our graph as being"}, {"start_time": 2450, "text": " decompose into those two areas, h and j. Okay, so the theorem states the following."}, {"start_time": 2450, "text": " If h is epsilon sparse, where epsilon sparse means that the number of edges is at most and squared"}, {"start_time": 2460, "text": " minus epsilon positive epsilon. So if h is epsilon sparse and j is c3 c4 free, then the problem admits"}, {"start_time": 2470, "text": " a kernel, which is that big, k squared plus k into one plus one over epsilon."}, {"start_time": 2480, "text": " So notice now that we only need that h is epsilon sparse. And we only require c3 c4 freeness"}, {"start_time": 2490, "text": " inside j, which is s union t, closed neighborhood, closed neighborhood of s union t."}, {"start_time": 2500, "text": " And this idea is actually is not a new idea. So this idea is is, okay, I had the drawing here,"}, {"start_time": 2510, "text": " I should have used it. So the idea comes from from has been used before. And it's what we call"}, {"start_time": 2510, "text": " the buffer technique for the token jumping problem. And then the solution behind the buffer technique"}, {"start_time": 2520, "text": " is very simple. So if I have s union t, but somewhere in the graph, which is not in the closed"}, {"start_time": 2530, "text": " neighborhood of s union t, I have a case sized independent set, then you are done. Right? If I"}, {"start_time": 2530, "text": " have a case sized independent set in h, then you're done. You can basically take all the tokens on s,"}, {"start_time": 2540, "text": " jump them into those independent yellow vertices in h, and then jump them back to t."}, {"start_time": 2550, "text": " So in some sense, when h has a large independent set, that's the easy case."}, {"start_time": 2560, "text": " Right? You're done. If you can find a large enough independent set in h, you're done."}, {"start_time": 2560, "text": " And that's what we call the buffer technique, because it's been also used to show that the problem"}, {"start_time": 2570, "text": " is FBT on planar graphs, for example, or k3j free graphs. So graphs without large bytes."}, {"start_time": 2570, "text": " So it's a well known technique. All right. So what do we show? So we're going to use the buffer"}, {"start_time": 2590, "text": " technique, and we're going to combine it with something else. So we show that you have a yes"}, {"start_time": 2590, "text": " instance, whenever one of those two conditions is true. The first condition is that"}, {"start_time": 2600, "text": " h is epsilon sparse and contains more than this many vertices. And this is relatively easy."}, {"start_time": 2610, "text": " When you contain this many vertices and you are epsilon sparse, then you will have a case"}, {"start_time": 2620, "text": " size independent set. And that's basically the buffer technique. When h is epsilon sparse and has"}, {"start_time": 2620, "text": " that many vertices or more, then h is guaranteed to have an independent set of size k and you're done."}, {"start_time": 2630, "text": " So now you are stuck with what happens inside j or the closed neighborhood of s-union t."}, {"start_time": 2640, "text": " And it turns out there, if you have c3c for freeness, the only thing you need on top of that to"}, {"start_time": 2650, "text": " guarantee a yes instance is a vertex of degree at least 3k. So if you have c3c for freeness inside j,"}, {"start_time": 2660, "text": " and the vertex of degree 3k, then again you get a yes instance. So let me prove"}, {"start_time": 2660, "text": " those two statements separately, because they will be basically what we need for the"}, {"start_time": 2670, "text": " for the final theorem, for the final theorem. So the first lemma as I told you, if h is epsilon sparse"}, {"start_time": 2680, "text": " and has more than this many vertices, then it's a yes instance because you have a case size"}, {"start_time": 2680, "text": " independent set in h. The idea of this proof is simple, it's a counting argument. And what you"}, {"start_time": 2690, "text": " need to do basically first is to show that h must contain a vertex of degree less than and over k."}, {"start_time": 2700, "text": " And then basically you apply the standard greedy packing algorithm for constructing an independent"}, {"start_time": 2700, "text": " set of size k. And the reason you show that the way you show that h has a vertex of degree less"}, {"start_time": 2710, "text": " than n over k is again standard counting argument and the hand shaking lemma. So if the minimum degree in"}, {"start_time": 2720, "text": " h was at least n over k, then the number of edges would be at least n squared over 2k,"}, {"start_time": 2720, "text": " which will only happen in an epsilon sparse graph when n is less than or equal 2k to the power 1 over"}, {"start_time": 2730, "text": " s. And the rest of the proof is basically an induction on k. Okay, and so that shows you that when"}, {"start_time": 2740, "text": " you do have an epsilon sparse graph with more than this many vertices, then we have a yes instance."}, {"start_time": 2750, "text": " All right, so how about the second part of the claim? So now what happens if we have a c3 c4"}, {"start_time": 2760, "text": " free j that has a vertex of degree 3k? Well, let's see what happens. So if we have a vertex of degree"}, {"start_time": 2770, "text": " 3k, and I'm going to circle it here in yellow. So how can the neighborhood of that vertex look?"}, {"start_time": 2770, "text": " Well, we know that j is c3 free. So the blue edges cannot exist, which means that the neighborhood"}, {"start_time": 2780, "text": " of the yellow vertex is an independent set inside j, not in the whole graph. Well, in fact,"}, {"start_time": 2790, "text": " in the whole well known, because we're only talking about j as a sub graph. Right, so the blue edges"}, {"start_time": 2800, "text": " cannot exist, because otherwise we will get a c3 inside j. All right, so now let's look at the"}, {"start_time": 2810, "text": " other vertices in s union t. The other the second observation that you need is that any vertex"}, {"start_time": 2820, "text": " other than the yellow vertex can have at most one neighbor in common with the yellow vertex."}, {"start_time": 2820, "text": " Because if you do have two neighbors in common, then you will get a c4."}, {"start_time": 2830, "text": " So now what happens if we have three k vertices in the neighborhood of the yellow vertex? Well,"}, {"start_time": 2840, "text": " at most two k of them can be connected to some vertex in s union t, and you will get at least k"}, {"start_time": 2850, "text": " of them, some k of them here, that are only connected to the yellow vertex. And so now basically,"}, {"start_time": 2860, "text": " instead of using a buffer inside h, we have just found a buffer inside j,"}, {"start_time": 2860, "text": " and we can use the same strategy. We can jump all the tokens here, starting of course by the yellow"}, {"start_time": 2870, "text": " token, and then jump them to where they need to go. So now combining those two"}, {"start_time": 2880, "text": " observations together, if you will, we get the following theorem. So if h is alpha sparse,"}, {"start_time": 2890, "text": " and j is c3c43, then the problem admits a kernel on this maneuver to c's."}, {"start_time": 2900, "text": " And it's basically a simple application of the previous two lemmas. If we have more than this"}, {"start_time": 2900, "text": " maneuver to c's in h, it's a trivial yes instance. If j has a vertex of degree 3k or more,"}, {"start_time": 2910, "text": " it's trivial yes instance, and now you combine all of this together, we know that s union t is"}, {"start_time": 2910, "text": " of size at most 2k, we know that the neighborhood of s union t is of size at most 2k times 3k,"}, {"start_time": 2920, "text": " which is roughly 6k squared. And now we know that the rest of the graph has at most that maneuver to c's."}, {"start_time": 2930, "text": " So basically, you sum up those numbers, and you get this bound."}, {"start_time": 2930, "text": " All right. So how does this theorem imply the result that I promised you to start with?"}, {"start_time": 2950, "text": " So that token jumping and token sliding admit kernel with order k squared vertices,"}, {"start_time": 2960, "text": " I mean, it also holds for bipartite c4 free graphs, right? Obviously because they are c3c43."}, {"start_time": 2970, "text": " So how do you get the kernel? Well, we know that j cannot contain more than 6k squared minus 2k"}, {"start_time": 2970, "text": " vertices. And we know from another theorem from another paper that c3 free graphs with k squared"}, {"start_time": 2980, "text": " over log k vertices must have an independent set of size at least k. And now we know that if h contains"}, {"start_time": 2990, "text": " more than this many vertices, then we will get the yes instance as well. Right? So it becomes an"}, {"start_time": 3000, "text": " immediate consequence of the previous theorem, but the previous theorem is even more general than"}, {"start_time": 3000, "text": " this corollary. So this corollary does not really use the full power of this theorem."}, {"start_time": 3010, "text": " All right. That's it. I think I'm fine. If you have questions, I will take them now."}, {"start_time": 3020, "text": " So it was 55 minutes, right? For the talk. I did not go under the talk."}, {"start_time": 3030, "text": " It's fine. We usually allow plus minus 10 minutes. That's all right."}, {"start_time": 3040, "text": " So I have a question about token sliding. Yes. So how crucial, what happens if one does not restrict"}, {"start_time": 3050, "text": " the independent sets during the configuration to be not of the same size,"}, {"start_time": 3050, "text": " is that is that very critical for the difficulty or the easiness of the problem?"}, {"start_time": 3060, "text": " Well, you have to be careful how you define that because in token sliding,"}, {"start_time": 3060, "text": " sliding tokens cannot leave the graph. That's correct, but the independent set sequence,"}, {"start_time": 3070, "text": " all the independent sets have to be the same size, right?"}, {"start_time": 3070, "text": " Well, if not some token disappeared at some point, and I'm not sure how it disappeared."}, {"start_time": 3080, "text": " Right? Because you start with something of size k, and you're going to something of size k,"}, {"start_time": 3090, "text": " you cannot leave the graph unless you define it in some way. So you will remain of size k throughout."}, {"start_time": 3100, "text": " But you can become slightly larger in k. But where does the new token come from?"}, {"start_time": 3100, "text": " So there is a third rule that I did not tell you about, which is called token addition and removal."}, {"start_time": 3110, "text": " So under that rule, we actually allow you to remove vertices and adversities as long as you remain"}, {"start_time": 3120, "text": " an independent set of size at least k."}, {"start_time": 3130, "text": " Does that answer your question?"}, {"start_time": 3130, "text": " Yeah, yeah, yeah, yeah."}, {"start_time": 3130, "text": " But in fact, it was shown that it was shown that, so addition and removal is equivalent to token"}, {"start_time": 3140, "text": " jiving. It doesn't, it never makes sense to add more tokens to your graph if you don't need them."}, {"start_time": 3150, "text": " You're only making your life harder into it if he's speaking."}, {"start_time": 3160, "text": " So the other question that I had is, I mean, I heard, I,"}, {"start_time": 3160, "text": " so is it possible to view this whole problem on an exponential size graph?"}, {"start_time": 3170, "text": " Where every vertex corresponds to an independent set in the original graph?"}, {"start_time": 3180, "text": " And then you have edges between two vertices. If there is an edge between two vertices of the"}, {"start_time": 3180, "text": " independent set, and now you're doing a reachability question, is that a meaningful way to think about this?"}, {"start_time": 3190, "text": " But that's exactly what we're doing."}, {"start_time": 3190, "text": " So the way you define your adjacency, I think, so you mean you define, you make two independent sets"}, {"start_time": 3200, "text": " adjacent if one can be reached from the other via a single slide or a single joint."}, {"start_time": 3200, "text": " Exactly. Yeah, one edge here. There is one pair, you would be which is adjacent."}, {"start_time": 3210, "text": " But that's, but that's exactly what we're doing."}, {"start_time": 3210, "text": " Okay, okay. Yeah."}, {"start_time": 3210, "text": " Right? I mean, if you, because we're looking at algorithms here, we kind of forget the structural"}, {"start_time": 3220, "text": " picture behind it. But this algorithm is finding a path in this graph that you're describing."}, {"start_time": 3220, "text": " Yeah, yeah, that's it."}, {"start_time": 3230, "text": " And what we're saying is you can do it in FBT time or not, depending on the problem we're talking about."}, {"start_time": 3240, "text": " Hi, Amir."}, {"start_time": 3240, "text": " Hi."}, {"start_time": 3240, "text": " Hi."}, {"start_time": 3240, "text": " Hi."}, {"start_time": 3240, "text": " How are you?"}, {"start_time": 3240, "text": " Hi."}, {"start_time": 3250, "text": " Yeah, I'm good. So I had a question."}, {"start_time": 3250, "text": " So, do problems remain equally hard if we bound the, if we have a restriction on the"}, {"start_time": 3250, "text": " number of times, we can move the token to a particular vertex."}, {"start_time": 3260, "text": " The number of times you can move a token to a particular vertex."}, {"start_time": 3270, "text": " And then, a lot of times, the tokens can be moved to a vertex."}, {"start_time": 3270, "text": " Well, that's definitely going to change the complexity in, at least intuitively speaking,"}, {"start_time": 3280, "text": " right? Because now you're saying maybe it will, if you're bounding that by a constant,"}, {"start_time": 3280, "text": " then you might be saying that I'm not allowing exponentially large sequences anymore."}, {"start_time": 3290, "text": " But in terms of exactly how the complexity changes, I don't have answers. I think it's a very"}, {"start_time": 3300, "text": " nice question to pose. Even in terms of a non-parameterized complexity standard complexity,"}, {"start_time": 3300, "text": " I think that that would be a very interesting question because, because it will definitely affect"}, {"start_time": 3310, "text": " the behavior. I'm not sure exactly how yet. I don't know of any results that ask this particular question."}, {"start_time": 3320, "text": " Okay. So, I had one more question in the W. Harnes result that you presented."}, {"start_time": 3320, "text": " So, do you know what is the length of the, the length of the changes? Actually, the number of"}, {"start_time": 3330, "text": " changes or flips that you make in your independence? This is just, yes, yes, yes, we do. So, here,"}, {"start_time": 3340, "text": " the number of changes is going to be where it's basically going to be the shortest possible sequence."}, {"start_time": 3350, "text": " So, it's going to, it's basically going to be, so if you think about the simple construction,"}, {"start_time": 3350, "text": " this one, it's basically literally going to be, these guys are going to move here."}, {"start_time": 3360, "text": " So, H is going to cost me one slide and then they're all going to, and now this guy is going to"}, {"start_time": 3370, "text": " move here and now I will pay one slide for each one here. Now, this is the simplified version of it."}, {"start_time": 3380, "text": " Once you go to the complete version of it, you have some extra slides within the path,"}, {"start_time": 3380, "text": " but you can also count those. Okay. So, but does this mean that, so, does this mean that at a particular"}, {"start_time": 3390, "text": " vertex, we are placing the token at most ones? In this case, yes. Okay. In this case, yes."}, {"start_time": 3400, "text": " Okay. So, this problem should be hard even if we bound the number of times tokens can be moved to"}, {"start_time": 3410, "text": " a vertex, right? Yes. Okay. Yes. So, so here in this case, yes. Absolutely. Okay. Thanks."}, {"start_time": 3420, "text": " So, Akansha, I have a remark about your question. So, if a vertex, if a vertex cannot get a token to"}, {"start_time": 3430, "text": " a vertex, then it somehow seems to be selecting disjoint independent sets, a sequence of them,"}, {"start_time": 3440, "text": " and that may have some bearing on coloring, just a top level token."}, {"start_time": 3440, "text": " So, actually for the list, the W hardness case that I'm in present, it is exactly the case,"}, {"start_time": 3450, "text": " so we are not allowed to move the token like twice on the same vertex."}, {"start_time": 3460, "text": " Yeah. So, I didn't get your point of meaning, so getting this disjoint independence, it's actually"}, {"start_time": 3470, "text": " because if you say, if you think of it from my, the way I thought about it, that you are actually"}, {"start_time": 3470, "text": " trying to find a path in a large graph where every vertex corresponds to an independent site,"}, {"start_time": 3480, "text": " and you move from one independent site to another. So, but we can only move from one independent"}, {"start_time": 3480, "text": " set to the other if the the change is like in case of token sliding, it's one probably."}, {"start_time": 3490, "text": " Yeah. That's what I mean. So, it looks to be that you're asking for a collection of"}, {"start_time": 3500, "text": " independent sets which are vertex disjoints. If the token sequence of independent sets which are"}, {"start_time": 3510, "text": " vertex disjoints. Yeah. So, if I may, I think I think a conscious question would be more relevant"}, {"start_time": 3520, "text": " in a place where we don't have a monotone sequence, meaning a sequence. So, we need a version of"}, {"start_time": 3520, "text": " the problem or some cases of the problem where a vertex has to be visited multiple times"}, {"start_time": 3530, "text": " to find solutions. And that is known to be the case for some versions or some statements of the"}, {"start_time": 3530, "text": " problem. And in fact, the conscious also, this was the crucial difference between piece-based"}, {"start_time": 3540, "text": " completeness and NP completeness of sliding versus jumping in bipartite graphs. So, it was because"}, {"start_time": 3550, "text": " we were able to show that no vertex will be visited more than once. Okay. In the other problem."}, {"start_time": 3550, "text": " So, so that's why it's definitely an interesting question to pose, but you have to be careful"}, {"start_time": 3560, "text": " in what context you pose it. Great. I don't know if that kind of settles. Answer is your question."}, {"start_time": 3570, "text": " Yes, yes, it does. All right. Thanks. You're welcome."}, {"start_time": 3570, "text": " Any more questions?"}, {"start_time": 3600, "text": " I guess not. Yeah, I don't think that I know more questions. I will just once again announce the"}, {"start_time": 3620, "text": " parametrized algorithm 301 workshop, which is going to happen in December. The link has been posted"}, {"start_time": 3630, "text": " once again in the chat. Some advanced topics in parametrized complexity will be discussed."}, {"start_time": 3630, "text": " Those interested can have a look and register for it. And yeah, if there are some more questions,"}, {"start_time": 3640, "text": " please ask away."}, {"start_time": 3660, "text": " So, anyone can register for the school? Yes, here's anyone can."}, {"start_time": 3680, "text": " Cool. Yeah, it's free and it's online and yeah, it's open to everyone."}, {"start_time": 3680, "text": " Awesome. So, I can share it with my students as well. Of course, of course, please do. Yeah, that's"}, {"start_time": 3690, "text": " good. And we assume some basic understanding of parametrized algorithms, but we have already shared"}, {"start_time": 3690, "text": " a link on the page where students can go and go through some previous lectures in parametrized"}, {"start_time": 3700, "text": " algorithms if they wish to just brace up or revise stuff."}, {"start_time": 3710, "text": " All right, so I guess, okay, I don't think there are any more questions. So, I think it's a good time"}, {"start_time": 3720, "text": " to wrap up. So, thank you once again for the summit for agreeing to give the talk. It was really"}, {"start_time": 3730, "text": " nice to have you and it was really good to have something different than what we usually hear in"}, {"start_time": 3730, "text": " every parametrized complexity talk, at least most of them. So, and yeah, these are really"}, {"start_time": 3740, "text": " interesting problems to think of one. And thank you to the audience for being with us and"}, {"start_time": 3740, "text": " that's it for today's wrap up. See you all next week. Thank you. Bye. Thank you. Bye."}]